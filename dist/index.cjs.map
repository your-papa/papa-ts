{"version":3,"sources":["../src/index.ts","../src/providers/errors.ts","../src/providers/helpers.ts","../src/providers/dynamicImport.ts","../src/providers/openaiProvider.ts","../src/providers/anthropicProvider.ts","../src/providers/ollamaProvider.ts","../src/providers/sapAICoreProvider.ts","../src/providers/ProviderRegistry.ts","../src/agent/Agent.ts","../src/memory/ThreadStore.ts","../src/utils/logger.ts","../src/agent/build.ts","../src/telemetry/Telemetry.ts","../src/telemetry/LangfuseTelemetry.ts","../src/telemetry/LangsmithTelemetry.ts","../src/memory/InMemoryThreadStore.ts","../src/memory/LocalStorageThreadStore.ts","../src/memory/IndexedDBThreadStore.ts","../src/memory/FsThreadStore.ts"],"sourcesContent":["export {\n    ProviderRegistry,\n    ProviderRegistryError,\n    ProviderNotFoundError,\n    ModelNotFoundError,\n    ProviderImportError,\n    type BuiltInProviderModelMap,\n    type BuiltInProviderOptions,\n    type ChatModelFactory,\n    type EmbeddingModelFactory,\n    type ModelOptions,\n} from './providers/ProviderRegistry';\n\nexport { Agent, type AgentRunOptions, type AgentResult, type AgentOptions, type ChooseModelParams } from './agent/Agent';\nexport { buildAgent, type BuildAgentParams } from './agent/build';\n\nexport {\n    NullTelemetry,\n    type Telemetry,\n} from './telemetry/Telemetry';\nexport { LangfuseTelemetry, type LangfuseTelemetryOptions } from './telemetry/LangfuseTelemetry';\nexport { LangSmithTelemetry, type LangSmithTelemetryOptions } from './telemetry/LangsmithTelemetry';\n\nexport {\n    createSnapshot,\n    type ThreadStore,\n    type ThreadMessage,\n    type ThreadSnapshot,\n} from './memory/ThreadStore';\nexport { InMemoryThreadStore } from './memory/InMemoryThreadStore';\nexport { LocalStorageThreadStore, type LocalStorageThreadStoreOptions } from './memory/LocalStorageThreadStore';\nexport { IndexedDBThreadStore, type IndexedDBThreadStoreOptions } from './memory/IndexedDBThreadStore';\nexport { FsThreadStore, type FsThreadStoreOptions } from './memory/FsThreadStore';\n\n","export class ProviderRegistryError extends Error { }\n\nexport class ProviderNotFoundError extends ProviderRegistryError {\n    constructor(provider: string) {\n        super(`No provider registered with name \"${provider}\".`);\n        this.name = 'ProviderNotFoundError';\n    }\n}\n\nexport class ModelNotFoundError extends ProviderRegistryError {\n    constructor(provider: string, model: string, type: 'chat' | 'embedding') {\n        super(`Model \"${model}\" not found for ${type} models in provider \"${provider}\".`);\n        this.name = 'ModelNotFoundError';\n    }\n}\n\nexport class ProviderImportError extends ProviderRegistryError {\n    constructor(provider: string, moduleName: string, cause?: unknown) {\n        const hint = `Install the module with \\`npm install ${moduleName}\\` in the host application.`;\n        const message = `Unable to load module \"${moduleName}\" for provider \"${provider}\". ${hint}`;\n        super(message);\n        this.name = 'ProviderImportError';\n        if (cause instanceof Error) {\n            this.stack = cause.stack;\n        }\n    }\n}\n\n","import type {\n    BuiltInProviderModelMap,\n    BuiltInProviderModelMapEntry,\n    ChatModelFactory,\n    EmbeddingModelFactory,\n} from './types';\n\nexport function firstKey<T extends Record<string, unknown>>(value: T | undefined): string | undefined {\n    if (!value) {\n        return undefined;\n    }\n    const [first] = Object.keys(value);\n    return first;\n}\n\nexport function normalizeDescriptor(value: string | BuiltInProviderModelMapEntry): BuiltInProviderModelMapEntry {\n    if (typeof value === 'string') {\n        return { model: value };\n    }\n    return value;\n}\n\nexport function createChatFactories(\n    entries: BuiltInProviderModelMap,\n    factoryCreator: (descriptor: BuiltInProviderModelMapEntry) => ChatModelFactory,\n): Record<string, ChatModelFactory> {\n    return Object.entries(entries).reduce<Record<string, ChatModelFactory>>((acc, [alias, descriptor]) => {\n        const normalized = normalizeDescriptor(descriptor);\n        acc[alias] = factoryCreator(normalized);\n        return acc;\n    }, {});\n}\n\nexport function createEmbeddingFactories(\n    entries: BuiltInProviderModelMap,\n    factoryCreator: (descriptor: BuiltInProviderModelMapEntry) => EmbeddingModelFactory,\n): Record<string, EmbeddingModelFactory> {\n    return Object.entries(entries).reduce<Record<string, EmbeddingModelFactory>>((acc, [alias, descriptor]) => {\n        const normalized = normalizeDescriptor(descriptor);\n        acc[alias] = factoryCreator(normalized);\n        return acc;\n    }, {});\n}\n\n","export const dynamicImport = new Function('modulePath', 'return import(modulePath);') as <T>(modulePath: string) => Promise<T>;\n\n","import type { BaseChatModel } from '@langchain/core/language_models/chat_models';\nimport type { EmbeddingsInterface } from '@langchain/core/embeddings';\nimport type {\n    BuiltInProviderModelMap,\n    BuiltInProviderModelMapEntry,\n    BuiltInProviderOptions,\n    ChatModelFactory,\n    EmbeddingModelFactory,\n    ProviderDefinition,\n} from './types';\nimport { ProviderImportError } from './errors';\nimport { dynamicImport } from './dynamicImport';\nimport { createChatFactories, createEmbeddingFactories, firstKey } from './helpers';\n\nconst DEFAULT_CHAT_ENTRIES: BuiltInProviderModelMap = {\n    'gpt-4o': 'gpt-4o',\n    'gpt-5': 'gpt-5',\n    'gpt-4o-mini': 'gpt-4o-mini',\n};\n\nconst DEFAULT_EMBEDDING_ENTRIES: BuiltInProviderModelMap = {\n    'text-embedding-3-large': 'text-embedding-3-large',\n    'text-embedding-3-small': 'text-embedding-3-small',\n};\n\nexport function createOpenAIProviderDefinition(options?: BuiltInProviderOptions): ProviderDefinition {\n    const chatEntries = options?.chatModels ?? DEFAULT_CHAT_ENTRIES;\n    const embeddingEntries = options?.embeddingModels ?? DEFAULT_EMBEDDING_ENTRIES;\n\n    return {\n        chatModels: createChatFactories(chatEntries, createOpenAIChatFactory),\n        embeddingModels: createEmbeddingFactories(embeddingEntries, createOpenAIEmbeddingFactory),\n        defaultChatModel: options?.defaultChatModel ?? firstKey(chatEntries),\n        defaultEmbeddingModel: options?.defaultEmbeddingModel ?? firstKey(embeddingEntries),\n    };\n}\n\nfunction createOpenAIChatFactory(descriptor: BuiltInProviderModelMapEntry): ChatModelFactory {\n    return async (options) => {\n        try {\n            const mod = await dynamicImport<{ ChatOpenAI: new (config: Record<string, unknown>) => BaseChatModel }>(\n                '@langchain/openai',\n            );\n            const ChatOpenAI = (mod as { ChatOpenAI: new (config: Record<string, unknown>) => BaseChatModel }).ChatOpenAI;\n            return new ChatOpenAI({ model: descriptor.model, ...(descriptor.options ?? {}), ...(options ?? {}) });\n        } catch (error) {\n            throw new ProviderImportError('openai', '@langchain/openai', error);\n        }\n    };\n}\n\nfunction createOpenAIEmbeddingFactory(descriptor: BuiltInProviderModelMapEntry): EmbeddingModelFactory {\n    return async (options) => {\n        try {\n            const mod = await dynamicImport<{ OpenAIEmbeddings: new (config: Record<string, unknown>) => EmbeddingsInterface }>(\n                '@langchain/openai',\n            );\n            const OpenAIEmbeddings = (\n                mod as { OpenAIEmbeddings: new (config: Record<string, unknown>) => EmbeddingsInterface }\n            ).OpenAIEmbeddings;\n            return new OpenAIEmbeddings({ model: descriptor.model, ...(descriptor.options ?? {}), ...(options ?? {}) });\n        } catch (error) {\n            throw new ProviderImportError('openai', '@langchain/openai', error);\n        }\n    };\n}\n\n","import type { BaseChatModel } from '@langchain/core/language_models/chat_models';\nimport type {\n    BuiltInProviderModelMap,\n    BuiltInProviderModelMapEntry,\n    BuiltInProviderOptions,\n    ChatModelFactory,\n    ProviderDefinition,\n} from './types';\nimport { ProviderImportError } from './errors';\nimport { dynamicImport } from './dynamicImport';\nimport { createChatFactories, firstKey } from './helpers';\n\nconst DEFAULT_CHAT_ENTRIES: BuiltInProviderModelMap = {\n    'claude-3-5-sonnet': 'claude-3-5-sonnet-latest',\n    'claude-3-5-haiku': 'claude-3-5-haiku-latest',\n};\n\nexport function createAnthropicProviderDefinition(options?: BuiltInProviderOptions): ProviderDefinition {\n    const chatEntries = options?.chatModels ?? DEFAULT_CHAT_ENTRIES;\n\n    return {\n        chatModels: createChatFactories(chatEntries, createAnthropicChatFactory),\n        embeddingModels: {},\n        defaultChatModel: options?.defaultChatModel ?? firstKey(chatEntries),\n    };\n}\n\nfunction createAnthropicChatFactory(descriptor: BuiltInProviderModelMapEntry): ChatModelFactory {\n    return async (options) => {\n        try {\n            const mod = await dynamicImport<{ ChatAnthropic: new (config: Record<string, unknown>) => BaseChatModel }>(\n                '@langchain/anthropic',\n            );\n            const ChatAnthropic = (\n                mod as { ChatAnthropic: new (config: Record<string, unknown>) => BaseChatModel }\n            ).ChatAnthropic;\n            return new ChatAnthropic({ model: descriptor.model, ...(descriptor.options ?? {}), ...(options ?? {}) });\n        } catch (error) {\n            throw new ProviderImportError('anthropic', '@langchain/anthropic', error);\n        }\n    };\n}\n\n","import type { BaseChatModel } from '@langchain/core/language_models/chat_models';\nimport type { EmbeddingsInterface } from '@langchain/core/embeddings';\nimport type {\n    BuiltInProviderModelMap,\n    BuiltInProviderModelMapEntry,\n    BuiltInProviderOptions,\n    ChatModelFactory,\n    EmbeddingModelFactory,\n    ProviderDefinition,\n} from './types';\nimport { ProviderImportError } from './errors';\nimport { dynamicImport } from './dynamicImport';\nimport { createChatFactories, createEmbeddingFactories, firstKey } from './helpers';\n\nconst DEFAULT_CHAT_ENTRIES: BuiltInProviderModelMap = {\n    llama3: 'llama3',\n};\n\nconst DEFAULT_EMBEDDING_ENTRIES: BuiltInProviderModelMap = {\n    'nomic-embed-text': 'nomic-embed-text',\n};\n\nexport function createOllamaProviderDefinition(options?: BuiltInProviderOptions): ProviderDefinition {\n    const chatEntries = options?.chatModels ?? DEFAULT_CHAT_ENTRIES;\n    const embeddingEntries = options?.embeddingModels ?? DEFAULT_EMBEDDING_ENTRIES;\n\n    return {\n        chatModels: createChatFactories(chatEntries, createOllamaChatFactory),\n        embeddingModels: createEmbeddingFactories(embeddingEntries, createOllamaEmbeddingFactory),\n        defaultChatModel: options?.defaultChatModel ?? firstKey(chatEntries),\n        defaultEmbeddingModel: options?.defaultEmbeddingModel ?? firstKey(embeddingEntries),\n    };\n}\n\nfunction createOllamaChatFactory(descriptor: BuiltInProviderModelMapEntry): ChatModelFactory {\n    return async (options) => {\n        try {\n            const mod = await dynamicImport<{ ChatOllama: new (config: Record<string, unknown>) => BaseChatModel }>(\n                '@langchain/ollama',\n            );\n            const ChatOllama = (mod as { ChatOllama: new (config: Record<string, unknown>) => BaseChatModel }).ChatOllama;\n            return new ChatOllama({ model: descriptor.model, ...(descriptor.options ?? {}), ...(options ?? {}) });\n        } catch (error) {\n            throw new ProviderImportError('ollama', '@langchain/ollama', error);\n        }\n    };\n}\n\nfunction createOllamaEmbeddingFactory(descriptor: BuiltInProviderModelMapEntry): EmbeddingModelFactory {\n    return async (options) => {\n        try {\n            const mod = await dynamicImport<{\n                OllamaEmbeddings: new (config: Record<string, unknown>) => EmbeddingsInterface;\n            }>('@langchain/ollama');\n            const OllamaEmbeddings = (\n                mod as { OllamaEmbeddings: new (config: Record<string, unknown>) => EmbeddingsInterface }\n            ).OllamaEmbeddings;\n            return new OllamaEmbeddings({ model: descriptor.model, ...(descriptor.options ?? {}), ...(options ?? {}) });\n        } catch (error) {\n            throw new ProviderImportError('ollama', '@langchain/ollama', error);\n        }\n    };\n}\n\n","import type { BaseChatModel } from '@langchain/core/language_models/chat_models';\nimport type { LangChainOrchestrationModuleConfig } from '@sap-ai-sdk/langchain';\nimport type {\n    ChatModelFactory,\n    ProviderDefinition,\n    SapAICoreModelEntry,\n    SapAICoreProviderOptions,\n} from './types';\nimport { ProviderImportError } from './errors';\nimport { dynamicImport } from './dynamicImport';\nimport { firstKey } from './helpers';\n\nconst DEFAULT_CHAT_ENTRIES: Record<string, SapAICoreModelEntry> = {\n    'gpt-5': { model: 'gpt-5' },\n};\n\nexport function createSapAICoreProviderDefinition(options?: SapAICoreProviderOptions): ProviderDefinition {\n    const chatEntries = options?.chatModels ?? DEFAULT_CHAT_ENTRIES;\n\n    return {\n        chatModels: Object.entries(chatEntries).reduce<Record<string, ChatModelFactory>>((acc, [alias, descriptor]) => {\n            acc[alias] = createSapAICoreChatFactory(alias, descriptor);\n            return acc;\n        }, {}),\n        embeddingModels: {},\n        defaultChatModel: options?.defaultChatModel ?? firstKey(chatEntries),\n    };\n}\n\nfunction createSapAICoreChatFactory(alias: string, descriptor: SapAICoreModelEntry): ChatModelFactory {\n    return async (options) => {\n        try {\n            const mod = await dynamicImport<{\n                OrchestrationClient: new (\n                    config: LangChainOrchestrationModuleConfig,\n                    langchainOptions?: Record<string, unknown>,\n                ) => BaseChatModel;\n            }>('@sap-ai-sdk/langchain');\n\n            const orchestrationConfig: LangChainOrchestrationModuleConfig =\n                descriptor.config ??\n                ({\n                    promptTemplating: {\n                        model: {\n                            name: descriptor.model ?? alias,\n                        },\n                    },\n                } as LangChainOrchestrationModuleConfig);\n\n            const langchainOptions = {\n                ...(descriptor.options ?? {}),\n                ...(descriptor.langchainOptions ?? {}),\n                ...(options ?? {}),\n            };\n\n            return new mod.OrchestrationClient(orchestrationConfig, langchainOptions);\n        } catch (error) {\n            throw new ProviderImportError('sap-ai-core', '@sap-ai-sdk/langchain', error);\n        }\n    };\n}\n\n","import type { BaseChatModel } from '@langchain/core/language_models/chat_models';\nimport type { EmbeddingsInterface } from '@langchain/core/embeddings';\nimport type {\n    BuiltInProviderOptions,\n    ChatModelFactory,\n    EmbeddingModelFactory,\n    ModelOptions,\n    ProviderDefinition,\n    SapAICoreProviderOptions,\n} from './types';\nimport { ModelNotFoundError, ProviderNotFoundError } from './errors';\nimport { firstKey } from './helpers';\nimport { createOpenAIProviderDefinition } from './openaiProvider';\nimport { createAnthropicProviderDefinition } from './anthropicProvider';\nimport { createOllamaProviderDefinition } from './ollamaProvider';\nimport { createSapAICoreProviderDefinition } from './sapAICoreProvider';\n\ninterface InternalProviderDefinition {\n    chatModels: Record<string, ChatModelFactory>;\n    embeddingModels: Record<string, EmbeddingModelFactory>;\n    defaultChatModel?: string;\n    defaultEmbeddingModel?: string;\n}\n\nexport class ProviderRegistry {\n    private readonly providers = new Map<string, InternalProviderDefinition>();\n\n    registerProvider(name: string, definition: ProviderDefinition): this {\n        const key = ProviderRegistry.normalizeName(name);\n        const existing = this.providers.get(key) ?? {\n            chatModels: {},\n            embeddingModels: {},\n            defaultChatModel: undefined,\n            defaultEmbeddingModel: undefined,\n        } satisfies InternalProviderDefinition;\n\n        const chatModels: Record<string, ChatModelFactory> = {\n            ...existing.chatModels,\n            ...(definition.chatModels ?? {}),\n        };\n\n        const embeddingModels: Record<string, EmbeddingModelFactory> = {\n            ...existing.embeddingModels,\n            ...(definition.embeddingModels ?? {}),\n        };\n\n        const mergedDefinition: InternalProviderDefinition = {\n            chatModels,\n            embeddingModels,\n            defaultChatModel: definition.defaultChatModel ?? existing.defaultChatModel ?? firstKey(chatModels),\n            defaultEmbeddingModel: definition.defaultEmbeddingModel ?? existing.defaultEmbeddingModel ?? firstKey(embeddingModels),\n        };\n\n        this.providers.set(key, mergedDefinition);\n        return this;\n    }\n\n    hasProvider(name: string): boolean {\n        return this.providers.has(ProviderRegistry.normalizeName(name));\n    }\n\n    listProviders(): string[] {\n        return Array.from(this.providers.keys());\n    }\n\n    listChatModels(provider: string): string[] {\n        return Object.keys(this.getProvider(provider).chatModels);\n    }\n\n    listEmbeddingModels(provider: string): string[] {\n        return Object.keys(this.getProvider(provider).embeddingModels);\n    }\n\n    async getChatModel(provider: string, model?: string, options?: ModelOptions): Promise<BaseChatModel> {\n        const providerDef = this.getProvider(provider);\n        const modelName = model ?? providerDef.defaultChatModel;\n        if (!modelName) {\n            throw new ModelNotFoundError(provider, '(default)', 'chat');\n        }\n        const factory = providerDef.chatModels[modelName];\n        if (!factory) {\n            throw new ModelNotFoundError(provider, modelName, 'chat');\n        }\n        return factory(options);\n    }\n\n    async getEmbeddingModel(provider: string, model?: string, options?: ModelOptions): Promise<EmbeddingsInterface> {\n        const providerDef = this.getProvider(provider);\n        const modelName = model ?? providerDef.defaultEmbeddingModel;\n        if (!modelName) {\n            throw new ModelNotFoundError(provider, '(default)', 'embedding');\n        }\n        const factory = providerDef.embeddingModels[modelName];\n        if (!factory) {\n            throw new ModelNotFoundError(provider, modelName, 'embedding');\n        }\n        return factory(options);\n    }\n\n    useOpenAI(options?: BuiltInProviderOptions): this {\n        return this.registerProvider('openai', createOpenAIProviderDefinition(options));\n    }\n\n    useAnthropic(options?: BuiltInProviderOptions): this {\n        return this.registerProvider('anthropic', createAnthropicProviderDefinition(options));\n    }\n\n    useOllama(options?: BuiltInProviderOptions): this {\n        return this.registerProvider('ollama', createOllamaProviderDefinition(options));\n    }\n\n    useSapAICore(options?: SapAICoreProviderOptions): this {\n        return this.registerProvider('sap-ai-core', createSapAICoreProviderDefinition(options));\n    }\n\n    private getProvider(name: string): InternalProviderDefinition {\n        const key = ProviderRegistry.normalizeName(name);\n        const provider = this.providers.get(key);\n        if (!provider) {\n            throw new ProviderNotFoundError(name);\n        }\n        return provider;\n    }\n\n    private static normalizeName(name: string): string {\n        return name.trim().toLowerCase();\n    }\n}\n\nexport type {\n    ModelOptions,\n    ChatModelFactory,\n    EmbeddingModelFactory,\n    ProviderDefinition,\n    BuiltInProviderOptions,\n    BuiltInProviderModelMap,\n    BuiltInProviderModelMapEntry,\n    SapAICoreModelEntry,\n    SapAICoreProviderOptions,\n} from './types';\n\nexport {\n    ProviderRegistryError,\n    ProviderNotFoundError,\n    ModelNotFoundError,\n    ProviderImportError,\n} from './errors';\n","import { createAgent } from 'langchain';\nimport type { BaseChatModel } from '@langchain/core/language_models/chat_models';\nimport type { RunnableConfig } from '@langchain/core/runnables';\nimport type { BaseCheckpointSaver, CheckpointTuple } from '@langchain/langgraph';\nimport { MemorySaver } from '@langchain/langgraph';\n\nimport type { ProviderRegistry, ModelOptions } from '../providers/ProviderRegistry';\nimport type { Telemetry } from '../telemetry/Telemetry';\nimport {\n    createSnapshot,\n    type ThreadMessage,\n    type ThreadSnapshot,\n    type ThreadStore,\n} from '../memory/ThreadStore';\nimport { debugLog } from '../utils/logger';\n\nexport interface ChooseModelParams {\n    provider: string;\n    chatModel?: string;\n    options?: ModelOptions;\n}\n\nexport interface AgentRunOptions {\n    query: string;\n    threadId?: string;\n    metadata?: Record<string, unknown>;\n    configurable?: Record<string, unknown>;\n}\n\nexport interface AgentResult {\n    runId: string;\n    threadId: string;\n    durationMs: number;\n    messages: ThreadMessage[];\n    response?: unknown;\n    raw: unknown;\n}\n\nexport interface AgentOptions {\n    registry: ProviderRegistry;\n    telemetry?: Telemetry;\n    threadStore?: ThreadStore;\n    checkpointer?: BaseCheckpointSaver;\n    defaultPrompt?: string;\n}\n\ntype AgentRunnable = ReturnType<typeof createAgent>; // invoke(), stream(), etc.\n\ninterface SelectedModel {\n    provider: string;\n    name: string;\n    instance: BaseChatModel;\n    options?: ModelOptions;\n}\n\nexport class Agent {\n    private prompt: string;\n    private tools: readonly unknown[] = [];\n    private selectedModel?: SelectedModel;\n    private agentRunnable?: AgentRunnable;\n    private readonly checkpointer: BaseCheckpointSaver;\n    private readonly telemetry?: Telemetry;\n    private readonly threadStore?: ThreadStore;\n    private readonly registry: ProviderRegistry;\n    private dirty = true;\n\n    constructor(options: AgentOptions) {\n        this.registry = options.registry;\n        this.telemetry = options.telemetry;\n        this.threadStore = options.threadStore;\n        this.checkpointer = options.checkpointer ?? new MemorySaver();\n        this.prompt = options.defaultPrompt ?? 'You are a privacy-focused assistant.';\n        debugLog('agent.init', {\n            hasTelemetry: Boolean(this.telemetry),\n            hasThreadStore: Boolean(this.threadStore),\n            checkpointer: this.checkpointer.constructor?.name ?? 'unknown',\n        });\n    }\n\n    setPrompt(prompt: string): void {\n        this.prompt = prompt;\n        this.dirty = true;\n    }\n\n    bindTools(tools: readonly unknown[]): void {\n        this.tools = tools;\n        this.dirty = true;\n    }\n\n    async chooseModel(params: ChooseModelParams): Promise<void> {\n        const { provider, chatModel, options } = params;\n        const instance = await this.registry.getChatModel(provider, chatModel, options);\n        const modelName = chatModel ?? this.registry.listChatModels(provider)[0];\n        if (!modelName) {\n            throw new Error(`No chat models registered for provider \"${provider}\".`);\n        }\n        this.selectedModel = {\n            provider,\n            name: modelName,\n            instance,\n            options,\n        };\n        debugLog('agent.chooseModel', { provider, modelName, options });\n        this.dirty = true;\n    }\n\n    async run(options: AgentRunOptions): Promise<AgentResult> {\n        const { query } = options;\n        if (!this.selectedModel) {\n            throw new Error('No model selected. Call chooseModel() before run().');\n        }\n\n        if (!query || query.trim().length === 0) {\n            throw new Error('Query must be a non-empty string.');\n        }\n\n        const agent = await this.ensureAgent();\n        const runId = this.generateId();\n        const threadId = options.threadId ?? runId;\n        const startedAt = new Date();\n        debugLog('agent.run.start', {\n            runId,\n            threadId,\n            provider: this.selectedModel.provider,\n            model: this.selectedModel.name,\n            queryPreview: query.slice(0, 200),\n        });\n\n        const callbacks = this.telemetry?.getCallbacks?.();\n\n        const invokeConfig: RunnableConfig = {\n            configurable: {\n                thread_id: threadId,\n                ...(options.configurable ?? {}),\n            },\n            metadata: options.metadata,\n            callbacks: callbacks ?? undefined,\n        } as RunnableConfig;\n\n        const rawResult = await agent.invoke(\n            {\n                messages: [\n                    {\n                        role: 'user',\n                        content: query,\n                    },\n                ],\n            },\n            invokeConfig,\n        );\n\n        const finishedAt = new Date();\n        const messages = this.extractMessagesFromResult(rawResult);\n        if (this.threadStore) {\n            await this.threadStore.write(\n                createSnapshot({\n                    threadId,\n                    messages,\n                    metadata: {\n                        lastRunId: runId,\n                        model: this.selectedModel.name,\n                    },\n                }),\n            );\n            debugLog('agent.threadStore.write', { threadId, lastRunId: runId, messageCount: messages.length });\n        }\n\n        const result: AgentResult = {\n            runId,\n            threadId,\n            durationMs: finishedAt.getTime() - startedAt.getTime(),\n            messages,\n            response: this.extractResponse(messages),\n            raw: rawResult,\n        };\n\n        await this.telemetry?.onRunComplete?.(result);\n        debugLog('agent.run.complete', { runId, durationMs: result.durationMs, responsePreview: typeof result.response === 'string' ? (result.response as string).slice(0, 200) : undefined });\n\n        return result;\n    }\n\n    async getThreadHistory(threadId: string): Promise<ThreadSnapshot | undefined> {\n        if (this.threadStore) {\n            return this.threadStore.read(threadId);\n        }\n\n        if (this.checkpointer instanceof MemorySaver) {\n            const tuple = await this.checkpointer.getTuple({ configurable: { thread_id: threadId } });\n            if (!tuple) {\n                return undefined;\n            }\n            const messages = this.extractMessagesFromCheckpoint(tuple);\n            return createSnapshot({ threadId, messages });\n        }\n\n        return undefined;\n    }\n\n\n    private async ensureAgent(): Promise<AgentRunnable> {\n        if (!this.selectedModel) {\n            throw new Error('No model selected.');\n        }\n\n        if (this.agentRunnable && !this.dirty) {\n            return this.agentRunnable;\n        }\n\n        this.agentRunnable = createAgent({\n            model: this.selectedModel.instance,\n            tools: Array.isArray(this.tools) ? [...this.tools] : [],\n            systemPrompt: this.prompt,\n            checkpointer: this.checkpointer,\n        });\n        this.dirty = false;\n        return this.agentRunnable;\n    }\n\n    private extractMessagesFromResult(result: unknown): ThreadMessage[] {\n        if (!result || typeof result !== 'object' || !('messages' in result)) {\n            return [];\n        }\n        const messages = (result as { messages?: unknown }).messages;\n        if (!Array.isArray(messages)) {\n            return [];\n        }\n        return this.normalizeMessages(messages);\n    }\n\n    private extractMessagesFromCheckpoint(tuple: CheckpointTuple): ThreadMessage[] {\n        const channelValues = tuple.checkpoint?.channel_values as Record<string, unknown> | undefined;\n        if (!channelValues) {\n            return [];\n        }\n        const messages = channelValues.messages;\n        if (!Array.isArray(messages)) {\n            return [];\n        }\n        return this.normalizeMessages(messages);\n    }\n\n    private normalizeMessages(messages: unknown[]): ThreadMessage[] {\n        return messages.map((message) => {\n            if (message && typeof message === 'object') {\n                const role = typeof (message as { role?: unknown }).role === 'string' ? (message as { role: string }).role : 'unknown';\n                const toolCallId = typeof (message as { tool_call_id?: unknown }).tool_call_id === 'string'\n                    ? (message as { tool_call_id: string }).tool_call_id\n                    : undefined;\n                const name = typeof (message as { name?: unknown }).name === 'string' ? (message as { name: string }).name : undefined;\n                return {\n                    role,\n                    content: (message as { content?: unknown }).content ?? message,\n                    toolCallId,\n                    name,\n                    metadata: typeof (message as { metadata?: unknown }).metadata === 'object'\n                        ? ((message as { metadata: Record<string, unknown> }).metadata)\n                        : undefined,\n                } satisfies ThreadMessage;\n            }\n            return {\n                role: 'unknown',\n                content: message,\n            } satisfies ThreadMessage;\n        });\n    }\n\n    private extractResponse(messages: ThreadMessage[]): unknown {\n        if (messages.length === 0) {\n            return undefined;\n        }\n        const last = messages[messages.length - 1];\n        return last.content;\n    }\n\n    private generateId(): string {\n        if (typeof globalThis.crypto !== 'undefined' && 'randomUUID' in globalThis.crypto) {\n            return globalThis.crypto.randomUUID();\n        }\n        return `run_${Math.random().toString(36).slice(2, 10)}`;\n    }\n}\n","export interface ThreadMessage {\n  role: string;\n  content: unknown;\n  toolCallId?: string;\n  name?: string;\n  metadata?: Record<string, unknown>;\n}\n\nexport interface ThreadSnapshot {\n  threadId: string;\n  messages: ThreadMessage[];\n  metadata?: Record<string, unknown>;\n  updatedAt: number;\n}\n\nexport interface ThreadStore {\n  read(threadId: string): Promise<ThreadSnapshot | undefined>;\n  write(snapshot: ThreadSnapshot): Promise<void>;\n  delete(threadId: string): Promise<void>;\n  list(): Promise<ThreadSnapshot[]>;\n  clear(): Promise<void>;\n}\n\nexport function createSnapshot(params: {\n  threadId: string;\n  messages: ThreadMessage[];\n  metadata?: Record<string, unknown>;\n  updatedAt?: number;\n}): ThreadSnapshot {\n  const { threadId, messages, metadata, updatedAt } = params;\n  return {\n    threadId,\n    messages,\n    metadata,\n    updatedAt: updatedAt ?? Date.now(),\n  };\n}\n\n","type DebugFlag = boolean | string | undefined;\n\nfunction resolveFlagValue(value: DebugFlag): boolean | undefined {\n    if (typeof value === 'boolean') {\n        return value;\n    }\n    if (typeof value === 'string') {\n        return value.toLowerCase() === 'true' || value === '1';\n    }\n    return undefined;\n}\n\nconst globalFlag =\n    typeof globalThis !== 'undefined'\n        ? (globalThis as { PRIVACY_AGENT_DEBUG?: DebugFlag }).PRIVACY_AGENT_DEBUG\n        : undefined;\n\nconst envFlag = (() => {\n    if (typeof globalThis === 'undefined') {\n        return undefined;\n    }\n    const maybeProcess = (globalThis as { process?: { env?: Record<string, DebugFlag> } }).process;\n    return maybeProcess?.env?.PRIVACY_AGENT_DEBUG;\n})();\n\nconst isDebugEnabled = resolveFlagValue(globalFlag) ?? resolveFlagValue(envFlag) ?? false;\n\nexport function debugLog(scope: string, details: Record<string, unknown> | string): void {\n    if (!isDebugEnabled) {\n        return;\n    }\n    const globalConsole = typeof globalThis !== 'undefined' ? globalThis.console : undefined;\n    const logFn =\n        globalConsole && typeof globalConsole.debug === 'function'\n            ? globalConsole.debug.bind(globalConsole)\n            : globalConsole?.log?.bind(globalConsole);\n    if (!logFn) {\n        return;\n    }\n    const payload = typeof details === 'string' ? details : JSON.stringify(details, (_, value) => value, 2);\n    logFn(`[privacy-agent][${new Date().toISOString()}][${scope}]`, payload);\n}\n\n","import { createAgent } from 'langchain';\nimport type { BaseChatModel } from '@langchain/core/language_models/chat_models';\nimport type { BaseCheckpointSaver } from '@langchain/langgraph';\nimport { MemorySaver } from '@langchain/langgraph';\n\nexport interface BuildAgentParams {\n    model: BaseChatModel;\n    tools?: readonly unknown[];\n    systemPrompt?: string;\n    checkpointer?: BaseCheckpointSaver;\n}\n\nexport function buildAgent(params: BuildAgentParams) {\n    const { model, tools = [], systemPrompt, checkpointer } = params;\n    const toolList = Array.isArray(tools) ? [...tools] : [];\n    return createAgent({\n        model,\n        tools: toolList,\n        systemPrompt,\n        checkpointer: checkpointer ?? new MemorySaver(),\n    });\n}\n\n","import type { Callbacks } from '@langchain/core/callbacks/manager';\n\nimport type { AgentResult } from '../agent/Agent';\n\nexport interface Telemetry {\n    getCallbacks(): Callbacks | undefined;\n    onRunComplete?(result: AgentResult): Promise<void> | void;\n}\n\nexport class NullTelemetry implements Telemetry {\n    getCallbacks(): undefined {\n        return undefined;\n    }\n}\n\n","import { CallbackHandler } from '@langfuse/langchain';\nimport type { Callbacks } from '@langchain/core/callbacks/manager';\n\nimport type { Telemetry } from './Telemetry';\n\n// See https://langfuse.com/integrations/frameworks/langchain for the official integration pattern.\nexport interface LangfuseTelemetryOptions {\n    /** Optional user identifier to attach to traces. */\n    userId?: string;\n    /** Optional session identifier to group traces. */\n    sessionId?: string;\n    /** Optional tags forwarded to Langfuse. */\n    tags?: string[];\n    /** Optional version of the application emitting traces. */\n    version?: string;\n    /** Additional metadata stored alongside each trace. */\n    traceMetadata?: Record<string, unknown>;\n    /** When true, call `flush` on the handler after each run (useful in short-lived scripts). */\n    flushOnComplete?: boolean;\n}\n\nexport class LangfuseTelemetry implements Telemetry {\n    private readonly handler: CallbackHandler;\n    private readonly flushOnComplete: boolean;\n\n    constructor(options?: LangfuseTelemetryOptions) {\n        const { flushOnComplete = false, ...handlerOptions } = options ?? {};\n        this.handler = new CallbackHandler(handlerOptions);\n        this.flushOnComplete = flushOnComplete;\n    }\n\n    getCallbacks(): Callbacks {\n        return [this.handler];\n    }\n\n    async onRunComplete(): Promise<void> {\n        if (!this.flushOnComplete) {\n            return;\n        }\n        const maybeFlush = (this.handler as unknown as { flush?: () => Promise<void> }).flush;\n        if (typeof maybeFlush === 'function') {\n            await maybeFlush.call(this.handler);\n        }\n    }\n}\n\n","import { LangChainTracer, type LangChainTracerFields } from '@langchain/core/tracers/tracer_langchain';\nimport type { Callbacks } from '@langchain/core/callbacks/manager';\n\nimport type { Telemetry } from './Telemetry';\n\nexport interface LangSmithTelemetryOptions extends LangChainTracerFields {\n    /**\n     * Flush spans to LangSmith after each run. This is mainly useful in short-lived\n     * scripts (such as tests) where the Node.js process may exit immediately.\n     */\n    flushOnComplete?: boolean;\n}\n\nexport class LangSmithTelemetry implements Telemetry {\n    private readonly tracer: LangChainTracer;\n    private readonly flushOnComplete: boolean;\n\n    constructor(options?: LangSmithTelemetryOptions) {\n        const { flushOnComplete = false, ...fields } = options ?? {};\n        this.tracer = new LangChainTracer(fields);\n        this.flushOnComplete = flushOnComplete;\n    }\n\n    getCallbacks(): Callbacks {\n        return [this.tracer];\n    }\n\n    async onRunComplete(): Promise<void> {\n        if (!this.flushOnComplete) {\n            return;\n        }\n        const maybeFlush = (this.tracer as unknown as { flush?: () => Promise<void> }).flush;\n        if (typeof maybeFlush === 'function') {\n            await maybeFlush.call(this.tracer);\n        }\n    }\n}\n\n\n","import { createSnapshot, type ThreadSnapshot, type ThreadStore } from './ThreadStore';\n\nexport class InMemoryThreadStore implements ThreadStore {\n  private readonly store = new Map<string, ThreadSnapshot>();\n\n  async read(threadId: string): Promise<ThreadSnapshot | undefined> {\n    return this.store.get(threadId);\n  }\n\n  async write(snapshot: ThreadSnapshot): Promise<void> {\n    this.store.set(snapshot.threadId, createSnapshot(snapshot));\n  }\n\n  async delete(threadId: string): Promise<void> {\n    this.store.delete(threadId);\n  }\n\n  async list(): Promise<ThreadSnapshot[]> {\n    return Array.from(this.store.values()).sort((a, b) => b.updatedAt - a.updatedAt);\n  }\n\n  async clear(): Promise<void> {\n    this.store.clear();\n  }\n}\n\n","import { createSnapshot, type ThreadSnapshot, type ThreadStore } from './ThreadStore';\n\nexport interface LocalStorageThreadStoreOptions {\n  prefix?: string;\n  storage?: Storage;\n}\n\nexport class LocalStorageThreadStore implements ThreadStore {\n  private readonly prefix: string;\n  private readonly storage: Storage;\n\n  constructor(options?: LocalStorageThreadStoreOptions) {\n    this.prefix = options?.prefix ?? 'papa-agent-thread';\n    const storage = options?.storage ?? (typeof globalThis.localStorage !== 'undefined' ? globalThis.localStorage : undefined);\n    if (!storage) {\n      throw new Error('localStorage is not available in the current environment.');\n    }\n    this.storage = storage;\n  }\n\n  async read(threadId: string): Promise<ThreadSnapshot | undefined> {\n    const raw = this.storage.getItem(this.key(threadId));\n    if (!raw) {\n      return undefined;\n    }\n    return this.safeParse(raw);\n  }\n\n  async write(snapshot: ThreadSnapshot): Promise<void> {\n    const normalized = createSnapshot(snapshot);\n    this.storage.setItem(this.key(normalized.threadId), JSON.stringify(normalized));\n  }\n\n  async delete(threadId: string): Promise<void> {\n    this.storage.removeItem(this.key(threadId));\n  }\n\n  async list(): Promise<ThreadSnapshot[]> {\n    const entries: ThreadSnapshot[] = [];\n    for (let index = 0; index < this.storage.length; index += 1) {\n      const key = this.storage.key(index);\n      if (!key || !key.startsWith(this.prefix)) {\n        continue;\n      }\n      const value = this.storage.getItem(key);\n      if (!value) {\n        continue;\n      }\n      const snapshot = this.safeParse(value);\n      if (snapshot) {\n        entries.push(snapshot);\n      }\n    }\n    return entries.sort((a, b) => b.updatedAt - a.updatedAt);\n  }\n\n  async clear(): Promise<void> {\n    const keys: string[] = [];\n    for (let index = 0; index < this.storage.length; index += 1) {\n      const key = this.storage.key(index);\n      if (key && key.startsWith(this.prefix)) {\n        keys.push(key);\n      }\n    }\n    keys.forEach((key) => this.storage.removeItem(key));\n  }\n\n  private key(threadId: string): string {\n    return `${this.prefix}:${threadId}`;\n  }\n\n  private safeParse(raw: string): ThreadSnapshot | undefined {\n    try {\n      const parsed = JSON.parse(raw) as ThreadSnapshot;\n      if (!parsed || typeof parsed.threadId !== 'string' || !Array.isArray(parsed.messages)) {\n        return undefined;\n      }\n      return parsed;\n    } catch {\n      return undefined;\n    }\n  }\n}\n\n","import { createSnapshot, type ThreadSnapshot, type ThreadStore } from './ThreadStore';\n\nconst DEFAULT_DB_NAME = 'papa-agent-threads';\nconst DEFAULT_STORE_NAME = 'threads';\n\nexport interface IndexedDBThreadStoreOptions {\n  dbName?: string;\n  storeName?: string;\n}\n\nexport class IndexedDBThreadStore implements ThreadStore {\n  private readonly dbName: string;\n  private readonly storeName: string;\n  private dbPromise?: Promise<IDBDatabase>;\n\n  constructor(options?: IndexedDBThreadStoreOptions) {\n    if (typeof globalThis.indexedDB === 'undefined') {\n      throw new Error('indexedDB is not available in this environment.');\n    }\n    this.dbName = options?.dbName ?? DEFAULT_DB_NAME;\n    this.storeName = options?.storeName ?? DEFAULT_STORE_NAME;\n  }\n\n  async read(threadId: string): Promise<ThreadSnapshot | undefined> {\n    const db = await this.openDb();\n    return new Promise<ThreadSnapshot | undefined>((resolve, reject) => {\n      const transaction = db.transaction(this.storeName, 'readonly');\n      const store = transaction.objectStore(this.storeName);\n      const request = store.get(threadId);\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve(request.result as ThreadSnapshot | undefined);\n    });\n  }\n\n  async write(snapshot: ThreadSnapshot): Promise<void> {\n    const db = await this.openDb();\n    const normalized = createSnapshot(snapshot);\n    await new Promise<void>((resolve, reject) => {\n      const transaction = db.transaction(this.storeName, 'readwrite');\n      const store = transaction.objectStore(this.storeName);\n      const request = store.put(normalized);\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve();\n    });\n  }\n\n  async delete(threadId: string): Promise<void> {\n    const db = await this.openDb();\n    await new Promise<void>((resolve, reject) => {\n      const transaction = db.transaction(this.storeName, 'readwrite');\n      const store = transaction.objectStore(this.storeName);\n      const request = store.delete(threadId);\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve();\n    });\n  }\n\n  async list(): Promise<ThreadSnapshot[]> {\n    const db = await this.openDb();\n    return new Promise<ThreadSnapshot[]>((resolve, reject) => {\n      const transaction = db.transaction(this.storeName, 'readonly');\n      const store = transaction.objectStore(this.storeName);\n      const request = store.getAll();\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => {\n        const results = Array.isArray(request.result) ? (request.result as ThreadSnapshot[]) : [];\n        resolve(results.sort((a, b) => b.updatedAt - a.updatedAt));\n      };\n    });\n  }\n\n  async clear(): Promise<void> {\n    const db = await this.openDb();\n    await new Promise<void>((resolve, reject) => {\n      const transaction = db.transaction(this.storeName, 'readwrite');\n      const store = transaction.objectStore(this.storeName);\n      const request = store.clear();\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve();\n    });\n  }\n\n  private async openDb(): Promise<IDBDatabase> {\n    if (!this.dbPromise) {\n      this.dbPromise = new Promise<IDBDatabase>((resolve, reject) => {\n      const request = globalThis.indexedDB.open(this.dbName, 1);\n        request.onerror = () => reject(request.error);\n        request.onsuccess = () => resolve(request.result);\n        request.onupgradeneeded = () => {\n          const db = request.result;\n          if (!db.objectStoreNames.contains(this.storeName)) {\n            db.createObjectStore(this.storeName, { keyPath: 'threadId' });\n          }\n        };\n      });\n    }\n    return this.dbPromise;\n  }\n}\n\n","import { createSnapshot, type ThreadSnapshot, type ThreadStore } from './ThreadStore';\n\ntype FsModule = typeof import('node:fs/promises');\ntype PathModule = typeof import('node:path');\n\nexport interface FsThreadStoreOptions {\n  directory: string;\n  fileExtension?: string;\n}\n\nexport class FsThreadStore implements ThreadStore {\n  private readonly directory: string;\n  private readonly extension: string;\n  private fsModule?: FsModule;\n  private pathModule?: PathModule;\n  private initPromise?: Promise<void>;\n\n  constructor(options: FsThreadStoreOptions) {\n    this.directory = options.directory;\n    this.extension = options.fileExtension ?? '.json';\n  }\n\n  async read(threadId: string): Promise<ThreadSnapshot | undefined> {\n    try {\n      const { fs, path } = await this.loadNodeModules();\n      const file = this.filePath(path, threadId);\n      const contents = await fs.readFile(file, 'utf8');\n      return JSON.parse(contents) as ThreadSnapshot;\n    } catch (error) {\n      if (this.isNotFoundError(error)) {\n        return undefined;\n      }\n      throw error;\n    }\n  }\n\n  async write(snapshot: ThreadSnapshot): Promise<void> {\n    const normalized = createSnapshot(snapshot);\n    const { fs, path } = await this.loadNodeModules();\n    await this.ensureDirectory(fs);\n    const file = this.filePath(path, normalized.threadId);\n    await fs.writeFile(file, JSON.stringify(normalized), 'utf8');\n  }\n\n  async delete(threadId: string): Promise<void> {\n    try {\n      const { fs, path } = await this.loadNodeModules();\n      await fs.unlink(this.filePath(path, threadId));\n    } catch (error) {\n      if (!this.isNotFoundError(error)) {\n        throw error;\n      }\n    }\n  }\n\n  async list(): Promise<ThreadSnapshot[]> {\n    const { fs, path } = await this.loadNodeModules();\n      await this.ensureDirectory(fs);\n    const entries = await fs.readdir(this.directory, { withFileTypes: true });\n    const snapshots: ThreadSnapshot[] = [];\n    for (const entry of entries) {\n      if (!entry.isFile() || !entry.name.endsWith(this.extension)) {\n        continue;\n      }\n      const file = path.join(this.directory, entry.name);\n      try {\n        const contents = await fs.readFile(file, 'utf8');\n        const snapshot = JSON.parse(contents) as ThreadSnapshot;\n        if (snapshot.threadId) {\n          snapshots.push(snapshot);\n        }\n      } catch (error) {\n        if (!this.isNotFoundError(error)) {\n          throw error;\n        }\n      }\n    }\n    return snapshots.sort((a, b) => b.updatedAt - a.updatedAt);\n  }\n\n  async clear(): Promise<void> {\n    const { fs, path } = await this.loadNodeModules();\n      await this.ensureDirectory(fs);\n    const entries = await fs.readdir(this.directory, { withFileTypes: true });\n    await Promise.all(\n      entries\n        .filter((entry) => entry.isFile() && entry.name.endsWith(this.extension))\n        .map((entry) => fs.unlink(path.join(this.directory, entry.name)).catch((error) => {\n          if (!this.isNotFoundError(error)) {\n            throw error;\n          }\n        })),\n    );\n  }\n\n  private async loadNodeModules(): Promise<{ fs: FsModule; path: PathModule }> {\n    if (!this.fsModule || !this.pathModule) {\n      const [fs, path] = await Promise.all([import('node:fs/promises'), import('node:path')]);\n      this.fsModule = fs;\n      this.pathModule = path;\n    }\n    return { fs: this.fsModule!, path: this.pathModule! };\n  }\n\n  private async ensureDirectory(fs: FsModule): Promise<void> {\n    if (!this.initPromise) {\n      this.initPromise = fs.mkdir(this.directory, { recursive: true }).then(() => undefined);\n    }\n    await this.initPromise;\n    // ensure directory still exists when called concurrently\n    await fs.mkdir(this.directory, { recursive: true }).catch((error) => {\n      if (!this.isEexistError(error)) {\n        throw error;\n      }\n    });\n  }\n\n  private filePath(path: PathModule, threadId: string): string {\n    const safeName = encodeURIComponent(threadId);\n    return path.join(this.directory, `${safeName}${this.extension}`);\n  }\n\n  private isNotFoundError(error: unknown): boolean {\n    return this.hasCode(error, 'ENOENT');\n  }\n\n  private isEexistError(error: unknown): boolean {\n    return this.hasCode(error, 'EEXIST');\n  }\n\n  private hasCode(error: unknown, code: string): boolean {\n    return typeof error === 'object' && error !== null && 'code' in error && (error as { code?: string }).code === code;\n  }\n}\n\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAO,IAAM,wBAAN,cAAoC,MAAM;AAAE;AAE5C,IAAM,wBAAN,cAAoC,sBAAsB;AAAA,EAC7D,YAAY,UAAkB;AAC1B,UAAM,qCAAqC,QAAQ,IAAI;AACvD,SAAK,OAAO;AAAA,EAChB;AACJ;AAEO,IAAM,qBAAN,cAAiC,sBAAsB;AAAA,EAC1D,YAAY,UAAkB,OAAe,MAA4B;AACrE,UAAM,UAAU,KAAK,mBAAmB,IAAI,wBAAwB,QAAQ,IAAI;AAChF,SAAK,OAAO;AAAA,EAChB;AACJ;AAEO,IAAM,sBAAN,cAAkC,sBAAsB;AAAA,EAC3D,YAAY,UAAkB,YAAoB,OAAiB;AAC/D,UAAM,OAAO,yCAAyC,UAAU;AAChE,UAAM,UAAU,0BAA0B,UAAU,mBAAmB,QAAQ,MAAM,IAAI;AACzF,UAAM,OAAO;AACb,SAAK,OAAO;AACZ,QAAI,iBAAiB,OAAO;AACxB,WAAK,QAAQ,MAAM;AAAA,IACvB;AAAA,EACJ;AACJ;;;ACnBO,SAAS,SAA4C,OAA0C;AAClG,MAAI,CAAC,OAAO;AACR,WAAO;AAAA,EACX;AACA,QAAM,CAAC,KAAK,IAAI,OAAO,KAAK,KAAK;AACjC,SAAO;AACX;AAEO,SAAS,oBAAoB,OAA4E;AAC5G,MAAI,OAAO,UAAU,UAAU;AAC3B,WAAO,EAAE,OAAO,MAAM;AAAA,EAC1B;AACA,SAAO;AACX;AAEO,SAAS,oBACZ,SACA,gBACgC;AAChC,SAAO,OAAO,QAAQ,OAAO,EAAE,OAAyC,CAAC,KAAK,CAAC,OAAO,UAAU,MAAM;AAClG,UAAM,aAAa,oBAAoB,UAAU;AACjD,QAAI,KAAK,IAAI,eAAe,UAAU;AACtC,WAAO;AAAA,EACX,GAAG,CAAC,CAAC;AACT;AAEO,SAAS,yBACZ,SACA,gBACqC;AACrC,SAAO,OAAO,QAAQ,OAAO,EAAE,OAA8C,CAAC,KAAK,CAAC,OAAO,UAAU,MAAM;AACvG,UAAM,aAAa,oBAAoB,UAAU;AACjD,QAAI,KAAK,IAAI,eAAe,UAAU;AACtC,WAAO;AAAA,EACX,GAAG,CAAC,CAAC;AACT;;;AC1CO,IAAM,gBAAgB,IAAI,SAAS,cAAc,4BAA4B;;;ACcpF,IAAM,uBAAgD;AAAA,EAClD,UAAU;AAAA,EACV,SAAS;AAAA,EACT,eAAe;AACnB;AAEA,IAAM,4BAAqD;AAAA,EACvD,0BAA0B;AAAA,EAC1B,0BAA0B;AAC9B;AAEO,SAAS,+BAA+B,SAAsD;AACjG,QAAM,cAAc,SAAS,cAAc;AAC3C,QAAM,mBAAmB,SAAS,mBAAmB;AAErD,SAAO;AAAA,IACH,YAAY,oBAAoB,aAAa,uBAAuB;AAAA,IACpE,iBAAiB,yBAAyB,kBAAkB,4BAA4B;AAAA,IACxF,kBAAkB,SAAS,oBAAoB,SAAS,WAAW;AAAA,IACnE,uBAAuB,SAAS,yBAAyB,SAAS,gBAAgB;AAAA,EACtF;AACJ;AAEA,SAAS,wBAAwB,YAA4D;AACzF,SAAO,OAAO,YAAY;AACtB,QAAI;AACA,YAAM,MAAM,MAAM;AAAA,QACd;AAAA,MACJ;AACA,YAAM,aAAc,IAA+E;AACnG,aAAO,IAAI,WAAW,EAAE,OAAO,WAAW,OAAO,GAAI,WAAW,WAAW,CAAC,GAAI,GAAI,WAAW,CAAC,EAAG,CAAC;AAAA,IACxG,SAAS,OAAO;AACZ,YAAM,IAAI,oBAAoB,UAAU,qBAAqB,KAAK;AAAA,IACtE;AAAA,EACJ;AACJ;AAEA,SAAS,6BAA6B,YAAiE;AACnG,SAAO,OAAO,YAAY;AACtB,QAAI;AACA,YAAM,MAAM,MAAM;AAAA,QACd;AAAA,MACJ;AACA,YAAM,mBACF,IACF;AACF,aAAO,IAAI,iBAAiB,EAAE,OAAO,WAAW,OAAO,GAAI,WAAW,WAAW,CAAC,GAAI,GAAI,WAAW,CAAC,EAAG,CAAC;AAAA,IAC9G,SAAS,OAAO;AACZ,YAAM,IAAI,oBAAoB,UAAU,qBAAqB,KAAK;AAAA,IACtE;AAAA,EACJ;AACJ;;;ACrDA,IAAMA,wBAAgD;AAAA,EAClD,qBAAqB;AAAA,EACrB,oBAAoB;AACxB;AAEO,SAAS,kCAAkC,SAAsD;AACpG,QAAM,cAAc,SAAS,cAAcA;AAE3C,SAAO;AAAA,IACH,YAAY,oBAAoB,aAAa,0BAA0B;AAAA,IACvE,iBAAiB,CAAC;AAAA,IAClB,kBAAkB,SAAS,oBAAoB,SAAS,WAAW;AAAA,EACvE;AACJ;AAEA,SAAS,2BAA2B,YAA4D;AAC5F,SAAO,OAAO,YAAY;AACtB,QAAI;AACA,YAAM,MAAM,MAAM;AAAA,QACd;AAAA,MACJ;AACA,YAAM,gBACF,IACF;AACF,aAAO,IAAI,cAAc,EAAE,OAAO,WAAW,OAAO,GAAI,WAAW,WAAW,CAAC,GAAI,GAAI,WAAW,CAAC,EAAG,CAAC;AAAA,IAC3G,SAAS,OAAO;AACZ,YAAM,IAAI,oBAAoB,aAAa,wBAAwB,KAAK;AAAA,IAC5E;AAAA,EACJ;AACJ;;;AC3BA,IAAMC,wBAAgD;AAAA,EAClD,QAAQ;AACZ;AAEA,IAAMC,6BAAqD;AAAA,EACvD,oBAAoB;AACxB;AAEO,SAAS,+BAA+B,SAAsD;AACjG,QAAM,cAAc,SAAS,cAAcD;AAC3C,QAAM,mBAAmB,SAAS,mBAAmBC;AAErD,SAAO;AAAA,IACH,YAAY,oBAAoB,aAAa,uBAAuB;AAAA,IACpE,iBAAiB,yBAAyB,kBAAkB,4BAA4B;AAAA,IACxF,kBAAkB,SAAS,oBAAoB,SAAS,WAAW;AAAA,IACnE,uBAAuB,SAAS,yBAAyB,SAAS,gBAAgB;AAAA,EACtF;AACJ;AAEA,SAAS,wBAAwB,YAA4D;AACzF,SAAO,OAAO,YAAY;AACtB,QAAI;AACA,YAAM,MAAM,MAAM;AAAA,QACd;AAAA,MACJ;AACA,YAAM,aAAc,IAA+E;AACnG,aAAO,IAAI,WAAW,EAAE,OAAO,WAAW,OAAO,GAAI,WAAW,WAAW,CAAC,GAAI,GAAI,WAAW,CAAC,EAAG,CAAC;AAAA,IACxG,SAAS,OAAO;AACZ,YAAM,IAAI,oBAAoB,UAAU,qBAAqB,KAAK;AAAA,IACtE;AAAA,EACJ;AACJ;AAEA,SAAS,6BAA6B,YAAiE;AACnG,SAAO,OAAO,YAAY;AACtB,QAAI;AACA,YAAM,MAAM,MAAM,cAEf,mBAAmB;AACtB,YAAM,mBACF,IACF;AACF,aAAO,IAAI,iBAAiB,EAAE,OAAO,WAAW,OAAO,GAAI,WAAW,WAAW,CAAC,GAAI,GAAI,WAAW,CAAC,EAAG,CAAC;AAAA,IAC9G,SAAS,OAAO;AACZ,YAAM,IAAI,oBAAoB,UAAU,qBAAqB,KAAK;AAAA,IACtE;AAAA,EACJ;AACJ;;;AClDA,IAAMC,wBAA4D;AAAA,EAC9D,SAAS,EAAE,OAAO,QAAQ;AAC9B;AAEO,SAAS,kCAAkC,SAAwD;AACtG,QAAM,cAAc,SAAS,cAAcA;AAE3C,SAAO;AAAA,IACH,YAAY,OAAO,QAAQ,WAAW,EAAE,OAAyC,CAAC,KAAK,CAAC,OAAO,UAAU,MAAM;AAC3G,UAAI,KAAK,IAAI,2BAA2B,OAAO,UAAU;AACzD,aAAO;AAAA,IACX,GAAG,CAAC,CAAC;AAAA,IACL,iBAAiB,CAAC;AAAA,IAClB,kBAAkB,SAAS,oBAAoB,SAAS,WAAW;AAAA,EACvE;AACJ;AAEA,SAAS,2BAA2B,OAAe,YAAmD;AAClG,SAAO,OAAO,YAAY;AACtB,QAAI;AACA,YAAM,MAAM,MAAM,cAKf,uBAAuB;AAE1B,YAAM,sBACF,WAAW,UACV;AAAA,QACG,kBAAkB;AAAA,UACd,OAAO;AAAA,YACH,MAAM,WAAW,SAAS;AAAA,UAC9B;AAAA,QACJ;AAAA,MACJ;AAEJ,YAAM,mBAAmB;AAAA,QACrB,GAAI,WAAW,WAAW,CAAC;AAAA,QAC3B,GAAI,WAAW,oBAAoB,CAAC;AAAA,QACpC,GAAI,WAAW,CAAC;AAAA,MACpB;AAEA,aAAO,IAAI,IAAI,oBAAoB,qBAAqB,gBAAgB;AAAA,IAC5E,SAAS,OAAO;AACZ,YAAM,IAAI,oBAAoB,eAAe,yBAAyB,KAAK;AAAA,IAC/E;AAAA,EACJ;AACJ;;;ACpCO,IAAM,mBAAN,MAAM,kBAAiB;AAAA,EACT,YAAY,oBAAI,IAAwC;AAAA,EAEzE,iBAAiB,MAAc,YAAsC;AACjE,UAAM,MAAM,kBAAiB,cAAc,IAAI;AAC/C,UAAM,WAAW,KAAK,UAAU,IAAI,GAAG,KAAK;AAAA,MACxC,YAAY,CAAC;AAAA,MACb,iBAAiB,CAAC;AAAA,MAClB,kBAAkB;AAAA,MAClB,uBAAuB;AAAA,IAC3B;AAEA,UAAM,aAA+C;AAAA,MACjD,GAAG,SAAS;AAAA,MACZ,GAAI,WAAW,cAAc,CAAC;AAAA,IAClC;AAEA,UAAM,kBAAyD;AAAA,MAC3D,GAAG,SAAS;AAAA,MACZ,GAAI,WAAW,mBAAmB,CAAC;AAAA,IACvC;AAEA,UAAM,mBAA+C;AAAA,MACjD;AAAA,MACA;AAAA,MACA,kBAAkB,WAAW,oBAAoB,SAAS,oBAAoB,SAAS,UAAU;AAAA,MACjG,uBAAuB,WAAW,yBAAyB,SAAS,yBAAyB,SAAS,eAAe;AAAA,IACzH;AAEA,SAAK,UAAU,IAAI,KAAK,gBAAgB;AACxC,WAAO;AAAA,EACX;AAAA,EAEA,YAAY,MAAuB;AAC/B,WAAO,KAAK,UAAU,IAAI,kBAAiB,cAAc,IAAI,CAAC;AAAA,EAClE;AAAA,EAEA,gBAA0B;AACtB,WAAO,MAAM,KAAK,KAAK,UAAU,KAAK,CAAC;AAAA,EAC3C;AAAA,EAEA,eAAe,UAA4B;AACvC,WAAO,OAAO,KAAK,KAAK,YAAY,QAAQ,EAAE,UAAU;AAAA,EAC5D;AAAA,EAEA,oBAAoB,UAA4B;AAC5C,WAAO,OAAO,KAAK,KAAK,YAAY,QAAQ,EAAE,eAAe;AAAA,EACjE;AAAA,EAEA,MAAM,aAAa,UAAkB,OAAgB,SAAgD;AACjG,UAAM,cAAc,KAAK,YAAY,QAAQ;AAC7C,UAAM,YAAY,SAAS,YAAY;AACvC,QAAI,CAAC,WAAW;AACZ,YAAM,IAAI,mBAAmB,UAAU,aAAa,MAAM;AAAA,IAC9D;AACA,UAAM,UAAU,YAAY,WAAW,SAAS;AAChD,QAAI,CAAC,SAAS;AACV,YAAM,IAAI,mBAAmB,UAAU,WAAW,MAAM;AAAA,IAC5D;AACA,WAAO,QAAQ,OAAO;AAAA,EAC1B;AAAA,EAEA,MAAM,kBAAkB,UAAkB,OAAgB,SAAsD;AAC5G,UAAM,cAAc,KAAK,YAAY,QAAQ;AAC7C,UAAM,YAAY,SAAS,YAAY;AACvC,QAAI,CAAC,WAAW;AACZ,YAAM,IAAI,mBAAmB,UAAU,aAAa,WAAW;AAAA,IACnE;AACA,UAAM,UAAU,YAAY,gBAAgB,SAAS;AACrD,QAAI,CAAC,SAAS;AACV,YAAM,IAAI,mBAAmB,UAAU,WAAW,WAAW;AAAA,IACjE;AACA,WAAO,QAAQ,OAAO;AAAA,EAC1B;AAAA,EAEA,UAAU,SAAwC;AAC9C,WAAO,KAAK,iBAAiB,UAAU,+BAA+B,OAAO,CAAC;AAAA,EAClF;AAAA,EAEA,aAAa,SAAwC;AACjD,WAAO,KAAK,iBAAiB,aAAa,kCAAkC,OAAO,CAAC;AAAA,EACxF;AAAA,EAEA,UAAU,SAAwC;AAC9C,WAAO,KAAK,iBAAiB,UAAU,+BAA+B,OAAO,CAAC;AAAA,EAClF;AAAA,EAEA,aAAa,SAA0C;AACnD,WAAO,KAAK,iBAAiB,eAAe,kCAAkC,OAAO,CAAC;AAAA,EAC1F;AAAA,EAEQ,YAAY,MAA0C;AAC1D,UAAM,MAAM,kBAAiB,cAAc,IAAI;AAC/C,UAAM,WAAW,KAAK,UAAU,IAAI,GAAG;AACvC,QAAI,CAAC,UAAU;AACX,YAAM,IAAI,sBAAsB,IAAI;AAAA,IACxC;AACA,WAAO;AAAA,EACX;AAAA,EAEA,OAAe,cAAc,MAAsB;AAC/C,WAAO,KAAK,KAAK,EAAE,YAAY;AAAA,EACnC;AACJ;;;AC/HA,uBAA4B;AAI5B,uBAA4B;;;ACmBrB,SAAS,eAAe,QAKZ;AACjB,QAAM,EAAE,UAAU,UAAU,UAAU,UAAU,IAAI;AACpD,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA,WAAW,aAAa,KAAK,IAAI;AAAA,EACnC;AACF;;;AClCA,SAAS,iBAAiB,OAAuC;AAC7D,MAAI,OAAO,UAAU,WAAW;AAC5B,WAAO;AAAA,EACX;AACA,MAAI,OAAO,UAAU,UAAU;AAC3B,WAAO,MAAM,YAAY,MAAM,UAAU,UAAU;AAAA,EACvD;AACA,SAAO;AACX;AAEA,IAAM,aACF,OAAO,eAAe,cACf,WAAmD,sBACpD;AAEV,IAAM,WAAW,MAAM;AACnB,MAAI,OAAO,eAAe,aAAa;AACnC,WAAO;AAAA,EACX;AACA,QAAM,eAAgB,WAAiE;AACvF,SAAO,cAAc,KAAK;AAC9B,GAAG;AAEH,IAAM,iBAAiB,iBAAiB,UAAU,KAAK,iBAAiB,OAAO,KAAK;AAE7E,SAAS,SAAS,OAAe,SAAiD;AACrF,MAAI,CAAC,gBAAgB;AACjB;AAAA,EACJ;AACA,QAAM,gBAAgB,OAAO,eAAe,cAAc,WAAW,UAAU;AAC/E,QAAM,QACF,iBAAiB,OAAO,cAAc,UAAU,aAC1C,cAAc,MAAM,KAAK,aAAa,IACtC,eAAe,KAAK,KAAK,aAAa;AAChD,MAAI,CAAC,OAAO;AACR;AAAA,EACJ;AACA,QAAM,UAAU,OAAO,YAAY,WAAW,UAAU,KAAK,UAAU,SAAS,CAAC,GAAG,UAAU,OAAO,CAAC;AACtG,QAAM,oBAAmB,oBAAI,KAAK,GAAE,YAAY,CAAC,KAAK,KAAK,KAAK,OAAO;AAC3E;;;AFcO,IAAM,QAAN,MAAY;AAAA,EACP;AAAA,EACA,QAA4B,CAAC;AAAA,EAC7B;AAAA,EACA;AAAA,EACS;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACT,QAAQ;AAAA,EAEhB,YAAY,SAAuB;AAC/B,SAAK,WAAW,QAAQ;AACxB,SAAK,YAAY,QAAQ;AACzB,SAAK,cAAc,QAAQ;AAC3B,SAAK,eAAe,QAAQ,gBAAgB,IAAI,6BAAY;AAC5D,SAAK,SAAS,QAAQ,iBAAiB;AACvC,aAAS,cAAc;AAAA,MACnB,cAAc,QAAQ,KAAK,SAAS;AAAA,MACpC,gBAAgB,QAAQ,KAAK,WAAW;AAAA,MACxC,cAAc,KAAK,aAAa,aAAa,QAAQ;AAAA,IACzD,CAAC;AAAA,EACL;AAAA,EAEA,UAAU,QAAsB;AAC5B,SAAK,SAAS;AACd,SAAK,QAAQ;AAAA,EACjB;AAAA,EAEA,UAAU,OAAiC;AACvC,SAAK,QAAQ;AACb,SAAK,QAAQ;AAAA,EACjB;AAAA,EAEA,MAAM,YAAY,QAA0C;AACxD,UAAM,EAAE,UAAU,WAAW,QAAQ,IAAI;AACzC,UAAM,WAAW,MAAM,KAAK,SAAS,aAAa,UAAU,WAAW,OAAO;AAC9E,UAAM,YAAY,aAAa,KAAK,SAAS,eAAe,QAAQ,EAAE,CAAC;AACvE,QAAI,CAAC,WAAW;AACZ,YAAM,IAAI,MAAM,2CAA2C,QAAQ,IAAI;AAAA,IAC3E;AACA,SAAK,gBAAgB;AAAA,MACjB;AAAA,MACA,MAAM;AAAA,MACN;AAAA,MACA;AAAA,IACJ;AACA,aAAS,qBAAqB,EAAE,UAAU,WAAW,QAAQ,CAAC;AAC9D,SAAK,QAAQ;AAAA,EACjB;AAAA,EAEA,MAAM,IAAI,SAAgD;AACtD,UAAM,EAAE,MAAM,IAAI;AAClB,QAAI,CAAC,KAAK,eAAe;AACrB,YAAM,IAAI,MAAM,qDAAqD;AAAA,IACzE;AAEA,QAAI,CAAC,SAAS,MAAM,KAAK,EAAE,WAAW,GAAG;AACrC,YAAM,IAAI,MAAM,mCAAmC;AAAA,IACvD;AAEA,UAAM,QAAQ,MAAM,KAAK,YAAY;AACrC,UAAM,QAAQ,KAAK,WAAW;AAC9B,UAAM,WAAW,QAAQ,YAAY;AACrC,UAAM,YAAY,oBAAI,KAAK;AAC3B,aAAS,mBAAmB;AAAA,MACxB;AAAA,MACA;AAAA,MACA,UAAU,KAAK,cAAc;AAAA,MAC7B,OAAO,KAAK,cAAc;AAAA,MAC1B,cAAc,MAAM,MAAM,GAAG,GAAG;AAAA,IACpC,CAAC;AAED,UAAM,YAAY,KAAK,WAAW,eAAe;AAEjD,UAAM,eAA+B;AAAA,MACjC,cAAc;AAAA,QACV,WAAW;AAAA,QACX,GAAI,QAAQ,gBAAgB,CAAC;AAAA,MACjC;AAAA,MACA,UAAU,QAAQ;AAAA,MAClB,WAAW,aAAa;AAAA,IAC5B;AAEA,UAAM,YAAY,MAAM,MAAM;AAAA,MAC1B;AAAA,QACI,UAAU;AAAA,UACN;AAAA,YACI,MAAM;AAAA,YACN,SAAS;AAAA,UACb;AAAA,QACJ;AAAA,MACJ;AAAA,MACA;AAAA,IACJ;AAEA,UAAM,aAAa,oBAAI,KAAK;AAC5B,UAAM,WAAW,KAAK,0BAA0B,SAAS;AACzD,QAAI,KAAK,aAAa;AAClB,YAAM,KAAK,YAAY;AAAA,QACnB,eAAe;AAAA,UACX;AAAA,UACA;AAAA,UACA,UAAU;AAAA,YACN,WAAW;AAAA,YACX,OAAO,KAAK,cAAc;AAAA,UAC9B;AAAA,QACJ,CAAC;AAAA,MACL;AACA,eAAS,2BAA2B,EAAE,UAAU,WAAW,OAAO,cAAc,SAAS,OAAO,CAAC;AAAA,IACrG;AAEA,UAAM,SAAsB;AAAA,MACxB;AAAA,MACA;AAAA,MACA,YAAY,WAAW,QAAQ,IAAI,UAAU,QAAQ;AAAA,MACrD;AAAA,MACA,UAAU,KAAK,gBAAgB,QAAQ;AAAA,MACvC,KAAK;AAAA,IACT;AAEA,UAAM,KAAK,WAAW,gBAAgB,MAAM;AAC5C,aAAS,sBAAsB,EAAE,OAAO,YAAY,OAAO,YAAY,iBAAiB,OAAO,OAAO,aAAa,WAAY,OAAO,SAAoB,MAAM,GAAG,GAAG,IAAI,OAAU,CAAC;AAErL,WAAO;AAAA,EACX;AAAA,EAEA,MAAM,iBAAiB,UAAuD;AAC1E,QAAI,KAAK,aAAa;AAClB,aAAO,KAAK,YAAY,KAAK,QAAQ;AAAA,IACzC;AAEA,QAAI,KAAK,wBAAwB,8BAAa;AAC1C,YAAM,QAAQ,MAAM,KAAK,aAAa,SAAS,EAAE,cAAc,EAAE,WAAW,SAAS,EAAE,CAAC;AACxF,UAAI,CAAC,OAAO;AACR,eAAO;AAAA,MACX;AACA,YAAM,WAAW,KAAK,8BAA8B,KAAK;AACzD,aAAO,eAAe,EAAE,UAAU,SAAS,CAAC;AAAA,IAChD;AAEA,WAAO;AAAA,EACX;AAAA,EAGA,MAAc,cAAsC;AAChD,QAAI,CAAC,KAAK,eAAe;AACrB,YAAM,IAAI,MAAM,oBAAoB;AAAA,IACxC;AAEA,QAAI,KAAK,iBAAiB,CAAC,KAAK,OAAO;AACnC,aAAO,KAAK;AAAA,IAChB;AAEA,SAAK,oBAAgB,8BAAY;AAAA,MAC7B,OAAO,KAAK,cAAc;AAAA,MAC1B,OAAO,MAAM,QAAQ,KAAK,KAAK,IAAI,CAAC,GAAG,KAAK,KAAK,IAAI,CAAC;AAAA,MACtD,cAAc,KAAK;AAAA,MACnB,cAAc,KAAK;AAAA,IACvB,CAAC;AACD,SAAK,QAAQ;AACb,WAAO,KAAK;AAAA,EAChB;AAAA,EAEQ,0BAA0B,QAAkC;AAChE,QAAI,CAAC,UAAU,OAAO,WAAW,YAAY,EAAE,cAAc,SAAS;AAClE,aAAO,CAAC;AAAA,IACZ;AACA,UAAM,WAAY,OAAkC;AACpD,QAAI,CAAC,MAAM,QAAQ,QAAQ,GAAG;AAC1B,aAAO,CAAC;AAAA,IACZ;AACA,WAAO,KAAK,kBAAkB,QAAQ;AAAA,EAC1C;AAAA,EAEQ,8BAA8B,OAAyC;AAC3E,UAAM,gBAAgB,MAAM,YAAY;AACxC,QAAI,CAAC,eAAe;AAChB,aAAO,CAAC;AAAA,IACZ;AACA,UAAM,WAAW,cAAc;AAC/B,QAAI,CAAC,MAAM,QAAQ,QAAQ,GAAG;AAC1B,aAAO,CAAC;AAAA,IACZ;AACA,WAAO,KAAK,kBAAkB,QAAQ;AAAA,EAC1C;AAAA,EAEQ,kBAAkB,UAAsC;AAC5D,WAAO,SAAS,IAAI,CAAC,YAAY;AAC7B,UAAI,WAAW,OAAO,YAAY,UAAU;AACxC,cAAM,OAAO,OAAQ,QAA+B,SAAS,WAAY,QAA6B,OAAO;AAC7G,cAAM,aAAa,OAAQ,QAAuC,iBAAiB,WAC5E,QAAqC,eACtC;AACN,cAAM,OAAO,OAAQ,QAA+B,SAAS,WAAY,QAA6B,OAAO;AAC7G,eAAO;AAAA,UACH;AAAA,UACA,SAAU,QAAkC,WAAW;AAAA,UACvD;AAAA,UACA;AAAA,UACA,UAAU,OAAQ,QAAmC,aAAa,WAC1D,QAAkD,WACpD;AAAA,QACV;AAAA,MACJ;AACA,aAAO;AAAA,QACH,MAAM;AAAA,QACN,SAAS;AAAA,MACb;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EAEQ,gBAAgB,UAAoC;AACxD,QAAI,SAAS,WAAW,GAAG;AACvB,aAAO;AAAA,IACX;AACA,UAAM,OAAO,SAAS,SAAS,SAAS,CAAC;AACzC,WAAO,KAAK;AAAA,EAChB;AAAA,EAEQ,aAAqB;AACzB,QAAI,OAAO,WAAW,WAAW,eAAe,gBAAgB,WAAW,QAAQ;AAC/E,aAAO,WAAW,OAAO,WAAW;AAAA,IACxC;AACA,WAAO,OAAO,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,MAAM,GAAG,EAAE,CAAC;AAAA,EACzD;AACJ;;;AGzRA,IAAAC,oBAA4B;AAG5B,IAAAC,oBAA4B;AASrB,SAAS,WAAW,QAA0B;AACjD,QAAM,EAAE,OAAO,QAAQ,CAAC,GAAG,cAAc,aAAa,IAAI;AAC1D,QAAM,WAAW,MAAM,QAAQ,KAAK,IAAI,CAAC,GAAG,KAAK,IAAI,CAAC;AACtD,aAAO,+BAAY;AAAA,IACf;AAAA,IACA,OAAO;AAAA,IACP;AAAA,IACA,cAAc,gBAAgB,IAAI,8BAAY;AAAA,EAClD,CAAC;AACL;;;ACZO,IAAM,gBAAN,MAAyC;AAAA,EAC5C,eAA0B;AACtB,WAAO;AAAA,EACX;AACJ;;;ACbA,IAAAC,oBAAgC;AAqBzB,IAAM,oBAAN,MAA6C;AAAA,EAC/B;AAAA,EACA;AAAA,EAEjB,YAAY,SAAoC;AAC5C,UAAM,EAAE,kBAAkB,OAAO,GAAG,eAAe,IAAI,WAAW,CAAC;AACnE,SAAK,UAAU,IAAI,kCAAgB,cAAc;AACjD,SAAK,kBAAkB;AAAA,EAC3B;AAAA,EAEA,eAA0B;AACtB,WAAO,CAAC,KAAK,OAAO;AAAA,EACxB;AAAA,EAEA,MAAM,gBAA+B;AACjC,QAAI,CAAC,KAAK,iBAAiB;AACvB;AAAA,IACJ;AACA,UAAM,aAAc,KAAK,QAAuD;AAChF,QAAI,OAAO,eAAe,YAAY;AAClC,YAAM,WAAW,KAAK,KAAK,OAAO;AAAA,IACtC;AAAA,EACJ;AACJ;;;AC5CA,8BAA4D;AAarD,IAAM,qBAAN,MAA8C;AAAA,EAChC;AAAA,EACA;AAAA,EAEjB,YAAY,SAAqC;AAC7C,UAAM,EAAE,kBAAkB,OAAO,GAAG,OAAO,IAAI,WAAW,CAAC;AAC3D,SAAK,SAAS,IAAI,wCAAgB,MAAM;AACxC,SAAK,kBAAkB;AAAA,EAC3B;AAAA,EAEA,eAA0B;AACtB,WAAO,CAAC,KAAK,MAAM;AAAA,EACvB;AAAA,EAEA,MAAM,gBAA+B;AACjC,QAAI,CAAC,KAAK,iBAAiB;AACvB;AAAA,IACJ;AACA,UAAM,aAAc,KAAK,OAAsD;AAC/E,QAAI,OAAO,eAAe,YAAY;AAClC,YAAM,WAAW,KAAK,KAAK,MAAM;AAAA,IACrC;AAAA,EACJ;AACJ;;;AClCO,IAAM,sBAAN,MAAiD;AAAA,EACrC,QAAQ,oBAAI,IAA4B;AAAA,EAEzD,MAAM,KAAK,UAAuD;AAChE,WAAO,KAAK,MAAM,IAAI,QAAQ;AAAA,EAChC;AAAA,EAEA,MAAM,MAAM,UAAyC;AACnD,SAAK,MAAM,IAAI,SAAS,UAAU,eAAe,QAAQ,CAAC;AAAA,EAC5D;AAAA,EAEA,MAAM,OAAO,UAAiC;AAC5C,SAAK,MAAM,OAAO,QAAQ;AAAA,EAC5B;AAAA,EAEA,MAAM,OAAkC;AACtC,WAAO,MAAM,KAAK,KAAK,MAAM,OAAO,CAAC,EAAE,KAAK,CAAC,GAAG,MAAM,EAAE,YAAY,EAAE,SAAS;AAAA,EACjF;AAAA,EAEA,MAAM,QAAuB;AAC3B,SAAK,MAAM,MAAM;AAAA,EACnB;AACF;;;ACjBO,IAAM,0BAAN,MAAqD;AAAA,EACzC;AAAA,EACA;AAAA,EAEjB,YAAY,SAA0C;AACpD,SAAK,SAAS,SAAS,UAAU;AACjC,UAAM,UAAU,SAAS,YAAY,OAAO,WAAW,iBAAiB,cAAc,WAAW,eAAe;AAChH,QAAI,CAAC,SAAS;AACZ,YAAM,IAAI,MAAM,2DAA2D;AAAA,IAC7E;AACA,SAAK,UAAU;AAAA,EACjB;AAAA,EAEA,MAAM,KAAK,UAAuD;AAChE,UAAM,MAAM,KAAK,QAAQ,QAAQ,KAAK,IAAI,QAAQ,CAAC;AACnD,QAAI,CAAC,KAAK;AACR,aAAO;AAAA,IACT;AACA,WAAO,KAAK,UAAU,GAAG;AAAA,EAC3B;AAAA,EAEA,MAAM,MAAM,UAAyC;AACnD,UAAM,aAAa,eAAe,QAAQ;AAC1C,SAAK,QAAQ,QAAQ,KAAK,IAAI,WAAW,QAAQ,GAAG,KAAK,UAAU,UAAU,CAAC;AAAA,EAChF;AAAA,EAEA,MAAM,OAAO,UAAiC;AAC5C,SAAK,QAAQ,WAAW,KAAK,IAAI,QAAQ,CAAC;AAAA,EAC5C;AAAA,EAEA,MAAM,OAAkC;AACtC,UAAM,UAA4B,CAAC;AACnC,aAAS,QAAQ,GAAG,QAAQ,KAAK,QAAQ,QAAQ,SAAS,GAAG;AAC3D,YAAM,MAAM,KAAK,QAAQ,IAAI,KAAK;AAClC,UAAI,CAAC,OAAO,CAAC,IAAI,WAAW,KAAK,MAAM,GAAG;AACxC;AAAA,MACF;AACA,YAAM,QAAQ,KAAK,QAAQ,QAAQ,GAAG;AACtC,UAAI,CAAC,OAAO;AACV;AAAA,MACF;AACA,YAAM,WAAW,KAAK,UAAU,KAAK;AACrC,UAAI,UAAU;AACZ,gBAAQ,KAAK,QAAQ;AAAA,MACvB;AAAA,IACF;AACA,WAAO,QAAQ,KAAK,CAAC,GAAG,MAAM,EAAE,YAAY,EAAE,SAAS;AAAA,EACzD;AAAA,EAEA,MAAM,QAAuB;AAC3B,UAAM,OAAiB,CAAC;AACxB,aAAS,QAAQ,GAAG,QAAQ,KAAK,QAAQ,QAAQ,SAAS,GAAG;AAC3D,YAAM,MAAM,KAAK,QAAQ,IAAI,KAAK;AAClC,UAAI,OAAO,IAAI,WAAW,KAAK,MAAM,GAAG;AACtC,aAAK,KAAK,GAAG;AAAA,MACf;AAAA,IACF;AACA,SAAK,QAAQ,CAAC,QAAQ,KAAK,QAAQ,WAAW,GAAG,CAAC;AAAA,EACpD;AAAA,EAEQ,IAAI,UAA0B;AACpC,WAAO,GAAG,KAAK,MAAM,IAAI,QAAQ;AAAA,EACnC;AAAA,EAEQ,UAAU,KAAyC;AACzD,QAAI;AACF,YAAM,SAAS,KAAK,MAAM,GAAG;AAC7B,UAAI,CAAC,UAAU,OAAO,OAAO,aAAa,YAAY,CAAC,MAAM,QAAQ,OAAO,QAAQ,GAAG;AACrF,eAAO;AAAA,MACT;AACA,aAAO;AAAA,IACT,QAAQ;AACN,aAAO;AAAA,IACT;AAAA,EACF;AACF;;;AChFA,IAAM,kBAAkB;AACxB,IAAM,qBAAqB;AAOpB,IAAM,uBAAN,MAAkD;AAAA,EACtC;AAAA,EACA;AAAA,EACT;AAAA,EAER,YAAY,SAAuC;AACjD,QAAI,OAAO,WAAW,cAAc,aAAa;AAC/C,YAAM,IAAI,MAAM,iDAAiD;AAAA,IACnE;AACA,SAAK,SAAS,SAAS,UAAU;AACjC,SAAK,YAAY,SAAS,aAAa;AAAA,EACzC;AAAA,EAEA,MAAM,KAAK,UAAuD;AAChE,UAAM,KAAK,MAAM,KAAK,OAAO;AAC7B,WAAO,IAAI,QAAoC,CAAC,SAAS,WAAW;AAClE,YAAM,cAAc,GAAG,YAAY,KAAK,WAAW,UAAU;AAC7D,YAAM,QAAQ,YAAY,YAAY,KAAK,SAAS;AACpD,YAAM,UAAU,MAAM,IAAI,QAAQ;AAClC,cAAQ,UAAU,MAAM,OAAO,QAAQ,KAAK;AAC5C,cAAQ,YAAY,MAAM,QAAQ,QAAQ,MAAoC;AAAA,IAChF,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,MAAM,UAAyC;AACnD,UAAM,KAAK,MAAM,KAAK,OAAO;AAC7B,UAAM,aAAa,eAAe,QAAQ;AAC1C,UAAM,IAAI,QAAc,CAAC,SAAS,WAAW;AAC3C,YAAM,cAAc,GAAG,YAAY,KAAK,WAAW,WAAW;AAC9D,YAAM,QAAQ,YAAY,YAAY,KAAK,SAAS;AACpD,YAAM,UAAU,MAAM,IAAI,UAAU;AACpC,cAAQ,UAAU,MAAM,OAAO,QAAQ,KAAK;AAC5C,cAAQ,YAAY,MAAM,QAAQ;AAAA,IACpC,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,OAAO,UAAiC;AAC5C,UAAM,KAAK,MAAM,KAAK,OAAO;AAC7B,UAAM,IAAI,QAAc,CAAC,SAAS,WAAW;AAC3C,YAAM,cAAc,GAAG,YAAY,KAAK,WAAW,WAAW;AAC9D,YAAM,QAAQ,YAAY,YAAY,KAAK,SAAS;AACpD,YAAM,UAAU,MAAM,OAAO,QAAQ;AACrC,cAAQ,UAAU,MAAM,OAAO,QAAQ,KAAK;AAC5C,cAAQ,YAAY,MAAM,QAAQ;AAAA,IACpC,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,OAAkC;AACtC,UAAM,KAAK,MAAM,KAAK,OAAO;AAC7B,WAAO,IAAI,QAA0B,CAAC,SAAS,WAAW;AACxD,YAAM,cAAc,GAAG,YAAY,KAAK,WAAW,UAAU;AAC7D,YAAM,QAAQ,YAAY,YAAY,KAAK,SAAS;AACpD,YAAM,UAAU,MAAM,OAAO;AAC7B,cAAQ,UAAU,MAAM,OAAO,QAAQ,KAAK;AAC5C,cAAQ,YAAY,MAAM;AACxB,cAAM,UAAU,MAAM,QAAQ,QAAQ,MAAM,IAAK,QAAQ,SAA8B,CAAC;AACxF,gBAAQ,QAAQ,KAAK,CAAC,GAAG,MAAM,EAAE,YAAY,EAAE,SAAS,CAAC;AAAA,MAC3D;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,QAAuB;AAC3B,UAAM,KAAK,MAAM,KAAK,OAAO;AAC7B,UAAM,IAAI,QAAc,CAAC,SAAS,WAAW;AAC3C,YAAM,cAAc,GAAG,YAAY,KAAK,WAAW,WAAW;AAC9D,YAAM,QAAQ,YAAY,YAAY,KAAK,SAAS;AACpD,YAAM,UAAU,MAAM,MAAM;AAC5B,cAAQ,UAAU,MAAM,OAAO,QAAQ,KAAK;AAC5C,cAAQ,YAAY,MAAM,QAAQ;AAAA,IACpC,CAAC;AAAA,EACH;AAAA,EAEA,MAAc,SAA+B;AAC3C,QAAI,CAAC,KAAK,WAAW;AACnB,WAAK,YAAY,IAAI,QAAqB,CAAC,SAAS,WAAW;AAC/D,cAAM,UAAU,WAAW,UAAU,KAAK,KAAK,QAAQ,CAAC;AACtD,gBAAQ,UAAU,MAAM,OAAO,QAAQ,KAAK;AAC5C,gBAAQ,YAAY,MAAM,QAAQ,QAAQ,MAAM;AAChD,gBAAQ,kBAAkB,MAAM;AAC9B,gBAAM,KAAK,QAAQ;AACnB,cAAI,CAAC,GAAG,iBAAiB,SAAS,KAAK,SAAS,GAAG;AACjD,eAAG,kBAAkB,KAAK,WAAW,EAAE,SAAS,WAAW,CAAC;AAAA,UAC9D;AAAA,QACF;AAAA,MACF,CAAC;AAAA,IACH;AACA,WAAO,KAAK;AAAA,EACd;AACF;;;ACxFO,IAAM,gBAAN,MAA2C;AAAA,EAC/B;AAAA,EACA;AAAA,EACT;AAAA,EACA;AAAA,EACA;AAAA,EAER,YAAY,SAA+B;AACzC,SAAK,YAAY,QAAQ;AACzB,SAAK,YAAY,QAAQ,iBAAiB;AAAA,EAC5C;AAAA,EAEA,MAAM,KAAK,UAAuD;AAChE,QAAI;AACF,YAAM,EAAE,IAAI,KAAK,IAAI,MAAM,KAAK,gBAAgB;AAChD,YAAM,OAAO,KAAK,SAAS,MAAM,QAAQ;AACzC,YAAM,WAAW,MAAM,GAAG,SAAS,MAAM,MAAM;AAC/C,aAAO,KAAK,MAAM,QAAQ;AAAA,IAC5B,SAAS,OAAO;AACd,UAAI,KAAK,gBAAgB,KAAK,GAAG;AAC/B,eAAO;AAAA,MACT;AACA,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAEA,MAAM,MAAM,UAAyC;AACnD,UAAM,aAAa,eAAe,QAAQ;AAC1C,UAAM,EAAE,IAAI,KAAK,IAAI,MAAM,KAAK,gBAAgB;AAChD,UAAM,KAAK,gBAAgB,EAAE;AAC7B,UAAM,OAAO,KAAK,SAAS,MAAM,WAAW,QAAQ;AACpD,UAAM,GAAG,UAAU,MAAM,KAAK,UAAU,UAAU,GAAG,MAAM;AAAA,EAC7D;AAAA,EAEA,MAAM,OAAO,UAAiC;AAC5C,QAAI;AACF,YAAM,EAAE,IAAI,KAAK,IAAI,MAAM,KAAK,gBAAgB;AAChD,YAAM,GAAG,OAAO,KAAK,SAAS,MAAM,QAAQ,CAAC;AAAA,IAC/C,SAAS,OAAO;AACd,UAAI,CAAC,KAAK,gBAAgB,KAAK,GAAG;AAChC,cAAM;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAAA,EAEA,MAAM,OAAkC;AACtC,UAAM,EAAE,IAAI,KAAK,IAAI,MAAM,KAAK,gBAAgB;AAC9C,UAAM,KAAK,gBAAgB,EAAE;AAC/B,UAAM,UAAU,MAAM,GAAG,QAAQ,KAAK,WAAW,EAAE,eAAe,KAAK,CAAC;AACxE,UAAM,YAA8B,CAAC;AACrC,eAAW,SAAS,SAAS;AAC3B,UAAI,CAAC,MAAM,OAAO,KAAK,CAAC,MAAM,KAAK,SAAS,KAAK,SAAS,GAAG;AAC3D;AAAA,MACF;AACA,YAAM,OAAO,KAAK,KAAK,KAAK,WAAW,MAAM,IAAI;AACjD,UAAI;AACF,cAAM,WAAW,MAAM,GAAG,SAAS,MAAM,MAAM;AAC/C,cAAM,WAAW,KAAK,MAAM,QAAQ;AACpC,YAAI,SAAS,UAAU;AACrB,oBAAU,KAAK,QAAQ;AAAA,QACzB;AAAA,MACF,SAAS,OAAO;AACd,YAAI,CAAC,KAAK,gBAAgB,KAAK,GAAG;AAChC,gBAAM;AAAA,QACR;AAAA,MACF;AAAA,IACF;AACA,WAAO,UAAU,KAAK,CAAC,GAAG,MAAM,EAAE,YAAY,EAAE,SAAS;AAAA,EAC3D;AAAA,EAEA,MAAM,QAAuB;AAC3B,UAAM,EAAE,IAAI,KAAK,IAAI,MAAM,KAAK,gBAAgB;AAC9C,UAAM,KAAK,gBAAgB,EAAE;AAC/B,UAAM,UAAU,MAAM,GAAG,QAAQ,KAAK,WAAW,EAAE,eAAe,KAAK,CAAC;AACxE,UAAM,QAAQ;AAAA,MACZ,QACG,OAAO,CAAC,UAAU,MAAM,OAAO,KAAK,MAAM,KAAK,SAAS,KAAK,SAAS,CAAC,EACvE,IAAI,CAAC,UAAU,GAAG,OAAO,KAAK,KAAK,KAAK,WAAW,MAAM,IAAI,CAAC,EAAE,MAAM,CAAC,UAAU;AAChF,YAAI,CAAC,KAAK,gBAAgB,KAAK,GAAG;AAChC,gBAAM;AAAA,QACR;AAAA,MACF,CAAC,CAAC;AAAA,IACN;AAAA,EACF;AAAA,EAEA,MAAc,kBAA+D;AAC3E,QAAI,CAAC,KAAK,YAAY,CAAC,KAAK,YAAY;AACtC,YAAM,CAAC,IAAI,IAAI,IAAI,MAAM,QAAQ,IAAI,CAAC,OAAO,aAAkB,GAAG,OAAO,MAAW,CAAC,CAAC;AACtF,WAAK,WAAW;AAChB,WAAK,aAAa;AAAA,IACpB;AACA,WAAO,EAAE,IAAI,KAAK,UAAW,MAAM,KAAK,WAAY;AAAA,EACtD;AAAA,EAEA,MAAc,gBAAgB,IAA6B;AACzD,QAAI,CAAC,KAAK,aAAa;AACrB,WAAK,cAAc,GAAG,MAAM,KAAK,WAAW,EAAE,WAAW,KAAK,CAAC,EAAE,KAAK,MAAM,MAAS;AAAA,IACvF;AACA,UAAM,KAAK;AAEX,UAAM,GAAG,MAAM,KAAK,WAAW,EAAE,WAAW,KAAK,CAAC,EAAE,MAAM,CAAC,UAAU;AACnE,UAAI,CAAC,KAAK,cAAc,KAAK,GAAG;AAC9B,cAAM;AAAA,MACR;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEQ,SAAS,MAAkB,UAA0B;AAC3D,UAAM,WAAW,mBAAmB,QAAQ;AAC5C,WAAO,KAAK,KAAK,KAAK,WAAW,GAAG,QAAQ,GAAG,KAAK,SAAS,EAAE;AAAA,EACjE;AAAA,EAEQ,gBAAgB,OAAyB;AAC/C,WAAO,KAAK,QAAQ,OAAO,QAAQ;AAAA,EACrC;AAAA,EAEQ,cAAc,OAAyB;AAC7C,WAAO,KAAK,QAAQ,OAAO,QAAQ;AAAA,EACrC;AAAA,EAEQ,QAAQ,OAAgB,MAAuB;AACrD,WAAO,OAAO,UAAU,YAAY,UAAU,QAAQ,UAAU,SAAU,MAA4B,SAAS;AAAA,EACjH;AACF;","names":["DEFAULT_CHAT_ENTRIES","DEFAULT_CHAT_ENTRIES","DEFAULT_EMBEDDING_ENTRIES","DEFAULT_CHAT_ENTRIES","import_langchain","import_langgraph","import_langchain"]}